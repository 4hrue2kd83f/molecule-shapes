<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>Build A Molecule Playground</title>

  <script src="../../sherpa/jquery-2.1.0.js"></script>
  <script src="../../sherpa/lodash-2.4.1.js"></script>
  <script src="../../sherpa/three-r68.js"></script>
  <script src="../../sherpa/has.js"></script>

  <script type="text/javascript" src="../../phetcommon/js/util/query-parameters.js"></script>

  <script data-main="../js/molecule-shapes-dev-config.js" src="../../sherpa/require-2.1.11.js"></script>

</head>
<body>
  <script>
    var Arr = window.Float64Array || Array;

    /*
     * Row-major indices:
     * 0 1 2
     * 3 4 5
     * 6 7 8
     */

    // 0-indexed
    function index( row, column ) {
      return 3 * row + column;
    }

    // transpose( matrix )
    function transpose3( matrix, result ) {
      var m1 = matrix[3];
      var m2 = matrix[6];
      var m3 = matrix[1];
      var m5 = matrix[7];
      var m6 = matrix[2];
      var m7 = matrix[5];
      result[0] = matrix[0];
      result[1] = m1;
      result[2] = m2;
      result[3] = m3;
      result[4] = matrix[4];
      result[5] = m5;
      result[6] = m6;
      result[7] = m7;
      result[8] = matrix[8];
    }

    function det3( matrix ) {
      return matrix[0] * matrix[4] * matrix[8] + matrix[1] * matrix[5] * matrix[6] + matrix[2] * matrix[3] * matrix[7] - matrix[2] * matrix[4] * matrix[6] - matrix[1] * matrix[3] * matrix[8] - matrix[0] * matrix[5] * matrix[7]
    }

    // left * right
    function mult3( left, right, result ) {
      var m0 = left[0] * right[0] + left[1] * right[3] + left[2] * right[6];
      var m1 = left[0] * right[1] + left[1] * right[4] + left[2] * right[7];
      var m2 = left[0] * right[2] + left[1] * right[5] + left[2] * right[8];
      var m3 = left[3] * right[0] + left[4] * right[3] + left[5] * right[6];
      var m4 = left[3] * right[1] + left[4] * right[4] + left[5] * right[7];
      var m5 = left[3] * right[2] + left[4] * right[5] + left[5] * right[8];
      var m6 = left[6] * right[0] + left[7] * right[3] + left[8] * right[6];
      var m7 = left[6] * right[1] + left[7] * right[4] + left[8] * right[7];
      var m8 = left[6] * right[2] + left[7] * right[5] + left[8] * right[8];
      result[0] = m0;
      result[1] = m1;
      result[2] = m2;
      result[3] = m3;
      result[4] = m4;
      result[5] = m5;
      result[6] = m6;
      result[7] = m7;
      result[8] = m8;
    }

    // transpose( left ) * right
    function mult3LeftTranspose( left, right, result ) {
      var m0 = left[0] * right[0] + left[3] * right[3] + left[6] * right[6];
      var m1 = left[0] * right[1] + left[3] * right[4] + left[6] * right[7];
      var m2 = left[0] * right[2] + left[3] * right[5] + left[6] * right[8];
      var m3 = left[1] * right[0] + left[4] * right[3] + left[7] * right[6];
      var m4 = left[1] * right[1] + left[4] * right[4] + left[7] * right[7];
      var m5 = left[1] * right[2] + left[4] * right[5] + left[7] * right[8];
      var m6 = left[2] * right[0] + left[5] * right[3] + left[8] * right[6];
      var m7 = left[2] * right[1] + left[5] * right[4] + left[8] * right[7];
      var m8 = left[2] * right[2] + left[5] * right[5] + left[8] * right[8];
      result[0] = m0;
      result[1] = m1;
      result[2] = m2;
      result[3] = m3;
      result[4] = m4;
      result[5] = m5;
      result[6] = m6;
      result[7] = m7;
      result[8] = m8;
    }

    //  left * transpose( right )
    function mult3RightTranspose( left, right, result ) {
      var m0 = left[0] * right[0] + left[1] * right[1] + left[2] * right[2];
      var m1 = left[0] * right[3] + left[1] * right[4] + left[2] * right[5];
      var m2 = left[0] * right[6] + left[1] * right[7] + left[2] * right[8];
      var m3 = left[3] * right[0] + left[4] * right[1] + left[5] * right[2];
      var m4 = left[3] * right[3] + left[4] * right[4] + left[5] * right[5];
      var m5 = left[3] * right[6] + left[4] * right[7] + left[5] * right[8];
      var m6 = left[6] * right[0] + left[7] * right[1] + left[8] * right[2];
      var m7 = left[6] * right[3] + left[7] * right[4] + left[8] * right[5];
      var m8 = left[6] * right[6] + left[7] * right[7] + left[8] * right[8];
      result[0] = m0;
      result[1] = m1;
      result[2] = m2;
      result[3] = m3;
      result[4] = m4;
      result[5] = m5;
      result[6] = m6;
      result[7] = m7;
      result[8] = m8;
    }

    //  transpose( left ) * transpose( right ) === transpose( right * left )
    function mult3BothTranspose( left, right, result ) {
      var m0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
      var m1 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
      var m2 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
      var m3 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
      var m4 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
      var m5 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
      var m6 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];
      var m7 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];
      var m8 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];
      result[0] = m0;
      result[1] = m1;
      result[2] = m2;
      result[3] = m3;
      result[4] = m4;
      result[5] = m5;
      result[6] = m6;
      result[7] = m7;
      result[8] = m8;
    }

    // in-place
    function swapNegateColumn( matrix, idx0, idx1 ) {
      var tmp0 = matrix[idx0];
      var tmp1 = matrix[idx0 + 3];
      var tmp2 = matrix[idx0 + 6];

      matrix[idx0] = matrix[idx1];
      matrix[idx0 + 3] = matrix[idx1 + 3];
      matrix[idx0 + 6] = matrix[idx1 + 6];

      matrix[idx1] = -tmp0;
      matrix[idx1 + 3] = -tmp1;
      matrix[idx1 + 6] = -tmp2;
    }

    function reorderColumns3( matrix, result, idx0, idx1, idx2 ) {
      var m0 = matrix[idx0];
      var m3 = matrix[idx0 + 3];
      var m6 = matrix[idx0 + 6];

      var m1 = matrix[idx1];
      var m4 = matrix[idx1 + 3];
      var m7 = matrix[idx1 + 6];

      var m2 = matrix[idx2];
      var m5 = matrix[idx2 + 3];
      var m8 = matrix[idx2 + 6];

      result[0] = m0;
      result[1] = m1;
      result[2] = m2;
      result[3] = m3;
      result[4] = m4;
      result[5] = m5;
      result[6] = m6;
      result[7] = m7;
      result[8] = m8;
    }

    function setIdentity3( result ) {
      result[0] = result[4] = result[8] = 1; // diagonal
      result[1] = result[2] = result[3] = result[5] = result[6] = result[7] = 0; // non-diagonal
    }

    function setGivens3( result, cos, sin, idx1, idx2 ) {
      assert && assert( idx1 < idx2 );
      setIdentity3( result );
      result[index(idx1,idx1)] = cos;
      result[index(idx2,idx2)] = cos;
      result[index(idx1,idx2)] = sin;
      result[index(idx2,idx1)] = -sin;
    }

    var givensScratch = new Arr( 9 );
    var sqrtHalf = Math.sqrt( 0.5 );
    function applyJacobi3( curS, curQ, idx1, idx2 ) {
      var a11 = curS[index(idx1,idx1)];
      var a12 = curS[index(idx1,idx2)];
      var a22 = curS[index(idx2,idx2)];

      // approximate givens angle
      var lhs = a12 * a12;
      var rhs = a11 - a22;
      rhs = rhs * rhs;
      var useAngle = lhs < rhs;
      var w = 1 / Math.sqrt( lhs + rhs );
      setGivens3( givensScratch, b ? ( w * ( a11 - a22 ) ) : sqrtHalf, b ? ( w * a12 ) : sqrtHalf, idx1, idx2 );

      // // exact givens angle
      // var theta = 0.5 * Math.atan( 2 * a12 / ( a11 - a22 ) );
      // if ( Math.abs( theta ) > Math.PI / 4 ) {
      //   theta = theta > 0 ? Math.PI / 4 : -Math.PI / 4;
      // }
      // setGivens3( givensScratch, Math.cos( theta ), Math.sin( theta ), idx1, idx2 );

      // S' = Q * S * transpose( Q )
      mult3( givensScratch, curS, curS );
      mult3RightTranspose( curS, givensScratch, curS );

      // Q' = Q * curQ
      mult3( givensScratch, curQ, curQ );
    }
    // TODO: if necessary, hand-code the application of the givens for each index pair
    function jacobiIteration3( curS, curQ, n ) {
      // for 3x3, we eliminate non-diagonal entries iteratively
      for ( var i = 0; i < n; i++ ) {
        applyJacobi3( curS, curQ, 0, 1 );
        applyJacobi3( curS, curQ, 0, 2 );
        applyJacobi3( curS, curQ, 1, 2 );
      }
    }

    function qrAnnihilate( q, r, row, col ) {
      assert && assert( row > col ); // only in the lower-triangular area

      var epsilon = 0.0000000001; // TODO: see how far we can reduce this?
      var cos, sin;

      var diagonalValue = r[index(col, col)];
      var targetValue = r[index(row, col)];
      var diagonalSquared = diagonalValue * diagonalValue;
      var targetSquared = targetValue * targetValue;

      if ( diagonalSquared + targetSquared < epsilon ) {
        cos = diagonalValue > 0 ? 1 : 0;
        sin = 0;
      } else {
        var rsqr = 1 / Math.sqrt( diagonalSquared + targetSquared );
        cos = rsqr * diagonalValue;
        sin = rsqr * targetValue;
      }

      setGivens3( givensScratch, cos, sin, col, row );

      mult3( givensScratch, r, r );
      mult3RightTranspose( q, givensScratch, q );
    }

    var scratchS = new Arr( 9 );
    var scratchQ = new Arr( 9 );
    var scratchV = new Arr( 9 );
    var scratchB = new Arr( 9 );
    function svd3( a, jacobiIterationCount ) {
      var s = scratchS;
      var q = scratchQ;
      var v = scratchV;
      var b = scratchB;
      mult3LeftTranspose( a, a, s );
      setIdentity3( q );

      jacobiIteration3( s, q, jacobiIterationCount );
      transpose3( q, v ); // done with this Q until we reuse the scratch matrix later below for the QR decomposition

      mult3( a, v, b ); // B = AV

      // sort based on singular values
      var mag0 = b[0] * b[0] + b[3] * b[3] + b[6] * b[6]; // column vector magnitudes
      var mag1 = b[1] * b[1] + b[4] * b[4] + b[7] * b[7];
      var mag2 = b[2] * b[2] + b[5] * b[5] + b[8] * b[8];
      var tmpMag;
      if ( mag0 < mag1 ) {
        // swap magnitudes
        tmpMag = mag0;
        mag0 = mag1;
        mag1 = tmpMag;
        swapNegateColumn( b, 0, 1 );
        swapNegateColumn( v, 0, 1 );
      }
      if ( mag0 < mag2 ) {
        // swap magnitudes
        tmpMag = mag0;
        mag0 = mag2;
        mag2 = tmpMag;
        swapNegateColumn( b, 0, 2 );
        swapNegateColumn( v, 0, 2 );
      }
      if ( mag1 < mag2 ) {
        swapNegateColumn( b, 1, 2 );
        swapNegateColumn( v, 1, 2 );
      }

      // QR decomposition
      var r = b;
      setIdentity3( q ); // reusing Q now for the QR
      qrAnnihilate( q, r, 1, 0 );
      qrAnnihilate( q, r, 2, 0 );
      qrAnnihilate( q, r, 2, 1 );

      // just references
      return {
        u: q,
        s: r,
        v: v
      }
    }

    var a = new Arr( [1, 2, 7, 5, 2, 6, -1, -5, 4] ); // a:= {{1, 2, 7}, {5, 2, 6}, {-1, -5, 4}}
    var b = new Arr( [4, 3, 1, -7, 2, -1, -1, 0, -2] ); // b:= {{4, 3, 1}, {-7, 2, -1}, {-1, 0, -2}}
    var c = new Arr( 9 );

    mult3( a, b, c );
    console.log( c ); // {{-17, 7, -15}, {0, 19, -9}, {27, -13, -4}}
    mult3LeftTranspose( a, b, c );
    console.log( c ); // {{-30, 13, -2}, {-1, 10, 10}, {-18, 33, -7}}
    mult3RightTranspose( a, b, c );
    console.log( c ); // {{17, -10, -15}, {32, -37, -17}, {-15, -7, -7}}
    mult3BothTranspose( a, b, c );
    console.log( c ); // {{18, 4, 1}, {9, -5, 8}, {50, -41, -15}}

    var s = new Arr( 9 );
    var q = new Arr( 9 );
    mult3LeftTranspose( a, a, s );
    setIdentity3( q );

    // we need to wait until our config file is loaded before our require statement. apparently this was not guaranteed
    function check() {
      if ( window.loadedMoleculeShapesConfig ) {
        requirejs( [ 'molecule-shapes-dev-main',
                     'SCENERY/main',
                     'KITE/main',
                     'DOT/main',
                     'AXON/main',
                     'PHET_CORE/main' ], function(
                      devMain,
                      scenery,
                      kite,
                      dot,
                      axon,
                      core
                      ) {
          // put all of our dev-main into the global namespace
          _.extend( window, devMain );
          window.scenery = scenery;
          window.kite = kite;
          window.dot = dot;
          window.axon = axon;
          window.core = core;

          console.log( 'loaded' );
        } );
      } else {
        setTimeout( check, 4 );
      }
    }
    setTimeout( check, 4 );
  </script>
</body>
</html>
